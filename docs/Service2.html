<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§Ø­Ø§Øª</title>

  <!-- Local Leaflet (no Google, no external scripts) -->
  <link rel="stylesheet" href="./vendor/leaflet/leaflet.css" />
<script src="./vendor/leaflet/leaflet.js"></script>


  <style>
    :root{
      --bg: #f3f4f6;
      --card: #ffffff;
      --text: #111827;
      --muted: #374151;
      --border: rgba(0,0,0,.12);
      --soft: #f9fafb;
      --primary: #2563eb;
      --secondary: #475569;
      --danger: #dc2626;
      --warn: #f59e0b;
    }

    *{ box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin:0;
      font-family: Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    header{
      padding: 14px 18px;
      background: var(--card);
      border-bottom: 1px solid var(--border);
    }
    header h1{
      margin:0;
      font-size: 18px;
      font-weight: 800;
    }

    .wrap{
      height: calc(100% - 56px);
      display:grid;
      grid-template-columns: 420px 1fr;
      gap: 14px;
      padding: 14px;
    }

    .card{
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      display:flex;
      flex-direction: column;
      min-width: 0;
    }

    .card h2{
      margin: 0 0 10px;
      font-size: 15px;
      font-weight: 800;
    }

    textarea{
      width: 100%;
      min-height: 220px;
      resize: vertical;
      background: #fff;
      color: var(--text);
      border: 1px solid rgba(0,0,0,.18);
      border-radius: 10px;
      padding: 10px;
      line-height: 1.55;
      font-family: Consolas, "Courier New", monospace;
      font-size: 13px;
    }

    .row{
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    button{
      background: var(--primary);
      color: #fff;
      border: 0;
      border-radius: 10px;
      padding: 9px 12px;
      font-weight: 800;
      cursor: pointer;
    }
    button.secondary{ background: var(--secondary); }
    button.danger{ background: var(--danger); }

    .hint{
      margin-top: 10px;
      background: var(--soft);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.6;
    }

    .msg{
      margin-top: 10px;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid rgba(37,99,235,.25);
      background: rgba(37,99,235,.08);
      font-size: 13px;
      display:none;
    }
    .msg.warn{
      border-color: rgba(245,158,11,.35);
      background: rgba(245,158,11,.12);
    }
    .msg.err{
      border-color: rgba(220,38,38,.35);
      background: rgba(220,38,38,.12);
    }

    .results{
      margin-top: 10px;
      display:none;
      gap: 8px;
    }
    .result-item{
      display:flex;
      justify-content: space-between;
      align-items:center;
      padding: 10px;
      border-radius: 10px;
      background: var(--soft);
      border: 1px solid var(--border);
    }
    .result-val{
      font-weight: 900;
      direction:ltr;
    }

    .map-card{
      padding: 12px;
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 600px;
    }
    #map{
      flex: 1;
      min-height: 500px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: #ffffff;
      width: 100%;
    }
    
    @media (max-width: 768px) {
      .map-card {
        min-height: 400px;
      }
      #map {
        min-height: 300px;
      }
    }

    /* Leaflet customization */
    #map .leaflet-container {
      background: #ffffff !important;
      font-family: 'Cairo', sans-serif;
    }

    .leaflet-control {
      background: #fff !important;
      border: 1px solid var(--border) !important;
      border-radius: 8px !important;
    }

    .leaflet-control-zoom-in,
    .leaflet-control-zoom-out {
      background-color: #fff !important;
      color: #333 !important;
      border-bottom: 1px solid var(--border) !important;
    }

    .leaflet-control-zoom-in:hover,
    .leaflet-control-zoom-out:hover {
      background-color: #f0f0f0 !important;
    }

    .measure-label {
      background: #fff !important;
      border: 1px solid #e74c3c !important;
      border-radius: 4px !important;
      padding: 2px 6px !important;
      font-size: 11px !important;
      color: #e74c3c !important;
      font-weight: bold !important;
    }

    input[type="file"]{ display:none; }

    /* Leaflet tweaks for better visibility in light theme */
    .leaflet-container { background: #ffffff; }
  </style>
</head>

<body>
<header>
  <h1>Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§Ø­Ø§Øª (N, E) â€” ÙˆØ¶Ø¹ Ù…Ø³ØªÙˆÙŠ (UTM/Ù…Ø­Ù„ÙŠ)</h1>
</header>

<div class="wrap">
  <div class="card">
    <h2>Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù†Ù‚Ø§Ø·</h2>

    <textarea id="coordsInput" placeholder="ÙƒÙ„ Ø³Ø·Ø± = Ù†Ù‚Ø·Ø© ÙˆØ§Ø­Ø¯Ø©

Ø£Ù…Ø«Ù„Ø© Ù…Ù‚Ø¨ÙˆÙ„Ø©:
N, E
N E
1, N, E
1 N E

ÙŠØ¯Ø¹Ù…: , Ø£Ùˆ ; Ø£Ùˆ Ù…Ø³Ø§ÙØ§Øª Ø£Ùˆ Tab"></textarea>

    <div class="row">
      <button id="btnDraw" type="button">Ø±Ø³Ù… ÙˆØ­Ø³Ø§Ø¨</button>
      <button id="btnImport" type="button" class="secondary">Ø§Ø³ØªÙŠØ±Ø§Ø¯ CSV/TXT</button>
      <button id="btnClear" type="button" class="danger">Ù…Ø³Ø­</button>
      <input id="fileInput" type="file" accept=".csv,.txt" />
    </div>

    <div class="row" style="gap: 8px; align-items: center; background: #f5f5f5; padding: 8px; border-radius: 4px; font-size: 12px;">
      <label style="margin: 0;">ğŸ” Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„ÙØµÙ„ Ø¨ÙŠÙ† Ø§Ù„Ù…Ø¶Ù„Ø¹Ø§Øª:</label>
      <select id="splitMethod" style="padding: 4px 8px; border: 1px solid #ccc; border-radius: 3px;">
        <option value="auto">ØªÙ„Ù‚Ø§Ø¦ÙŠ (Ø§Ù„Ø°ÙƒÙŠ - ÙŠÙØ¶Ù„ ID ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹)</option>
        <option value="id">Ø­Ø³Ø¨ ID (Ø§Ø³ØªØ®Ø¯Ù… Ù‡Ø°Ø§ Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ø£Ø±Ù‚Ø§Ù… ID)</option>
        <option value="duplicates">Ù†Ù‚Ø§Ø· Ù…ØªØ·Ø§Ø¨Ù‚Ø© ÙÙ‚Ø·</option>
        <option value="gaps">ÙØ¬ÙˆØ§Øª ÙƒØ¨ÙŠØ±Ø© ÙÙ‚Ø· (&gt;1000Ù…)</option>
      </select>
    </div>

    <div class="hint">
      <div>â€¢ Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø© ØªØ¹Ù…Ù„ Ø¯ÙˆÙ† Ø¥Ù†ØªØ±Ù†Øª (Ù„Ø§ Tiles). ØªØ¸Ù‡Ø± Ø´Ø¨ÙƒØ© Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ÙÙŠ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©.</div>
      <div>â€¢ Ø§Ø¹ØªØ¨Ø± Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª (N,E) Ø¨ÙˆØ­Ø¯Ø© Ø§Ù„Ù…ØªØ± Ø£Ùˆ Ø£ÙŠ ÙˆØ­Ø¯Ø© Ø®Ø·ÙŠØ©ØŒ ÙØªÙƒÙˆÙ† Ø§Ù„Ù…Ø³Ø§Ø­Ø© (ÙˆØ­Ø¯Ø©Â²).</div>
      <div>â€¢ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù†Ù‚Ø§Ø· Ù„Ø§ ØªØ¸Ù‡Ø±: ØºØ§Ù„Ø¨Ù‹Ø§ Leaflet Ù„Ù… ÙŠÙØ­Ù…Ù‘Ù„ (Ù…Ø³Ø§Ø± vendor/leaflet) Ø£Ùˆ Ø£Ù† Ø§Ù„ØµÙØ­Ø© Ù„ÙŠØ³Øª Ø¯Ø§Ø®Ù„ docs.</div>
      <div style="direction:ltr; margin-top:8px;">
        Ù…Ø«Ø§Ù„ Ø³Ø±ÙŠØ¹ Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±:<br/>
        3000, 5000<br/>
        3050, 5080<br/>
        2980, 5120<br/>
        2950, 5030
      </div>
    </div>

    <div id="message" class="msg"></div>

    <div class="results" id="areaResults">
      <div class="result-item">
        <span>Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ù‚Ø§Ø·:</span>
        <span class="result-val"><span id="res-count">0</span></span>
      </div>
      <div class="result-item">
        <span>Ø§Ù„Ù…Ø³Ø§Ø­Ø©:</span>
        <span class="result-val"><span id="res-area">0</span></span>
      </div>
      <div class="result-item">
        <span>Ø§Ù„Ù…Ø­ÙŠØ·:</span>
        <span class="result-val"><span id="res-perimeter">0</span></span>
      </div>
    </div>
  </div>

  <div class="card map-card">
    <div id="map"></div>
  </div>
</div>

<script src="vendor/leaflet/leaflet.js"></script>
<script>
(function(){
  // --- Hard stop if Leaflet not loaded ---
  if (typeof L === 'undefined') {
    const el = document.getElementById('message');
    el.className = 'msg err';
    el.style.display = 'block';
    el.textContent =
      'Leaflet Ù„Ù… ÙŠØªÙ… ØªØ­Ù…ÙŠÙ„Ù‡. ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ù…Ù„Ù Service2.html Ø¯Ø§Ø®Ù„ Ù…Ø¬Ù„Ø¯ docs ÙˆØ£Ù† Ø§Ù„Ù…Ø³Ø§Ø± docs/vendor/leaflet/leaflet.js Ù…ÙˆØ¬ÙˆØ¯.';
    return;
  }

  // --- UI elements ---
  const elInput   = document.getElementById('coordsInput');
  const elMsg     = document.getElementById('message');
  const elResults = document.getElementById('areaResults');

  const btnDraw   = document.getElementById('btnDraw');
  const btnImport = document.getElementById('btnImport');
  const btnClear  = document.getElementById('btnClear');
  const fileInput = document.getElementById('fileInput');

  function showMsg(text, kind){
    elMsg.style.display = 'block';
    elMsg.className = 'msg' + (kind ? (' ' + kind) : '');
    elMsg.textContent = text;
  }
  function hideMsg(){
    elMsg.style.display = 'none';
    elMsg.textContent = '';
  }
  function fmt(num, maxFrac){
    const n = Number(num);
    const fixed = n.toFixed(maxFrac ?? 3);
    return parseFloat(fixed).toString();
  }

  // --- Robust parsing (supports: N,E | N E | id,N,E | id N E | extra cols -> last two) ---
  function extractNumbers(line){
    const cleaned = (line || '').trim();
    if(!cleaned) return [];

    const tokens = cleaned
      .replace(/;/g, ',')
      .replace(/\t/g, ' ')
      .split(/[, ]+/)
      .filter(Boolean);

    const nums = [];
    for(const raw of tokens){
      let t = raw.trim();
      if(!/[0-9]/.test(t)) continue;

      // allow decimal comma in isolated token, convert to dot
      if(t.includes(',') && !t.includes('.')){
        const c = (t.match(/,/g)||[]).length;
        if(c === 1) t = t.replace(',', '.');
      }

      t = t.replace(/[^\d.+-]/g, '');
      const v = Number.parseFloat(t);
      if(Number.isFinite(v)) nums.push(v);
    }
    return nums;
  }

  function parsePoints(text){
    const lines = String(text || '').split(/\r?\n/);
    const pts = [];
    const bad = [];
    let lastId = null;

    for(let i=0;i<lines.length;i++){
      const nums = extractNumbers(lines[i]);
      if(nums.length === 0) continue;

      let N, E, id = null;
      if(nums.length === 2){
        [N, E] = nums;
      } else if(nums.length >= 3){
        // ÙŠÙˆØ¬Ø¯ Ø¹Ù…ÙˆØ¯ ID ÙÙŠ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© => id, N, E
        id = nums[0];
        N = nums[nums.length - 2];
        E = nums[nums.length - 1];
      } else {
        bad.push(i+1);
        continue;
      }

      if(!Number.isFinite(N) || !Number.isFinite(E)){
        bad.push(i+1);
        continue;
      }
      pts.push({ N, E, id });
      lastId = id;
    }

    return { pts, badLines: bad };
  }

  function pointsEqual(a, b, tolerance = 1e-9){
    return Math.abs(a.N - b.N) < tolerance && Math.abs(a.E - b.E) < tolerance;
  }

  function normalizeClosedDuplicate(pts){
    if(pts.length >= 2 && pointsEqual(pts[0], pts[pts.length - 1])){
      return pts.slice(0, -1);
    }
    return pts;
  }

  // --- Math (Shoelace with x=E, y=N) ---
  function computeAreaPerimeter(pts){
    const n = pts.length;
    if(n < 2) return { area: 0, perimeter: 0 };

    let sum = 0;
    let per = 0;

    for(let i=0;i<n;i++){
      const a = pts[i];
      const b = pts[(i+1) % n];

      // perimeter always computed for closed loop intent
      per += Math.hypot((b.E - a.E), (b.N - a.N));

      if(n >= 3){
        sum += (a.E * b.N) - (b.E * a.N);
      }
    }

    const area = (n >= 3) ? (Math.abs(sum) / 2) : 0;
    return { area, perimeter: per };
  }

  // --- Leaflet map (planar / CRS.Simple) ---
  let map = null;
  
  function initializeMap(){
    if(map) return;
    
    const mapEl = document.getElementById("map");
    if(!mapEl) return;
    
    // ØªÙ†Ø¸ÙŠÙ Ø£ÙŠ Ù…Ø¹Ø±ÙØ§Øª Ù‚Ø¯ÙŠÙ…Ø©
    if(mapEl._leaflet_id) {
      try { delete mapEl._leaflet_id; } catch {}
    }
    
    map = L.map('map', {
      crs: L.CRS.Simple,
      minZoom: -10,
      zoomSnap: 0.25,
      zoomDelta: 0.25,
      attributionControl: false,
      zoomControl: true
    });
    
    // Ø¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨ Ø§Ù„Ø­Ø¬Ù…
    setTimeout(() => {
      try {
        map.invalidateSize(true);
      } catch (e) {
        console.log('Error sizing map:', e);
      }
    }, 50);
    
    // Ù…Ø³ØªÙ…Ø¹ resize
    if(!window._service2MapResizeListener) {
      window._service2MapResizeListener = true;
      window.addEventListener('resize', () => {
        if(map) {
          try {
            map.invalidateSize(false);
          } catch (e) {
            console.log('Error on resize:', e);
          }
        }
      });
    }
  }
  
  initializeMap();
  const fixMapSize = () => {
    if(map) {
      try {
        map.invalidateSize(true);
      } catch (e) {}
    }
  };
setTimeout(fixMapSize, 0);
setTimeout(fixMapSize, 250);
window.addEventListener('resize', fixMapSize);


  // force Leaflet to compute sizes after layout
  setTimeout(() => map.invalidateSize(), 0);
  window.addEventListener('resize', () => map.invalidateSize());

  // Layers
  let gridLayer = null;
  let pointsLayer = null;
  let lineLayer = null;
  let polyLayer = null;

  function clearDraw(){
    if(pointsLayer){ map.removeLayer(pointsLayer); pointsLayer = null; }
    if(lineLayer){ map.removeLayer(lineLayer); lineLayer = null; }
    if(polyLayer){ map.removeLayer(polyLayer); polyLayer = null; }
  }

  function buildGrid(bounds, step){
    const yMin = bounds.getSouth(), yMax = bounds.getNorth();
    const xMin = bounds.getWest(),  xMax = bounds.getEast();

    const lines = [];
    for(let x = Math.floor(xMin/step)*step; x <= xMax; x += step){
      lines.push([[yMin, x],[yMax, x]]);
    }
    for(let y = Math.floor(yMin/step)*step; y <= yMax; y += step){
      lines.push([[y, xMin],[y, xMax]]);
    }

    return L.polyline(lines, { weight: 1, opacity: 0.35 }); // ÙƒØ§Ù†Øª 0.25
  }

  function setGridToBounds(bounds){
    if(gridLayer){ map.removeLayer(gridLayer); gridLayer = null; }

    const width  = Math.abs(bounds.getEast() - bounds.getWest());
    const height = Math.abs(bounds.getNorth() - bounds.getSouth());
    const span = Math.max(width, height);

    let step = 100;
    if(span > 50000) step = 5000;
    else if(span > 10000) step = 1000;
    else if(span > 2000)  step = 200;
    else if(span > 500)   step = 50;
    else if(span > 100)   step = 10;

    gridLayer = buildGrid(bounds, step).addTo(map);
  }

  // initial neutral view + grid
  const initBounds = L.latLngBounds([[0,0],[1000,1000]]);
  map.fitBounds(initBounds);
  setGridToBounds(initBounds);

  function toLatLngs(pts){
    // CRS.Simple expects [y, x] -> [N, E]
    return pts.map(p => [p.N, p.E]);
  }

  function computePolygonCentroid(pts){
    // Ø­Ø³Ø§Ø¨ Ù…Ø±ÙƒØ² Ø§Ù„Ù…Ø¶Ù„Ø¹ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ
    let cx = 0, cy = 0;
    const n = pts.length;
    for(let i = 0; i < n; i++){
      cx += pts[i].N;
      cy += pts[i].E;
    }
    return { N: cx / n, E: cy / n };
  }

  function render(ptsInput){
    hideMsg();
    clearDraw();

    // ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù†Ù‚Ø§Ø· Ø¥Ù„Ù‰ Ù…Ø¶Ù„Ø¹Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø©
    const polygons = splitPolygonsAtClosingPoint(ptsInput);
    
    if(polygons.length === 0 || ptsInput.length < 2){
      elResults.style.display = 'none';
      showMsg('Enter at least 2 points to draw.', 'warn');
      return;
    }

    // Ø¹Ø±Ø¶ ÙƒÙ„ Ù…Ø¶Ù„Ø¹ Ø¨Ù„ÙˆÙ† Ù…Ø®ØªÙ„Ù
    const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8'];
    pointsLayer = L.layerGroup();
    let allBounds = null;
    let totalArea = 0;
    let totalPerimeter = 0;
    let resultHTML = '';

    polygons.forEach((polyPts, polyIdx) => {
      if(polyPts.length < 2) return;
      
      const latlngs = toLatLngs(polyPts);
      const color = colors[polyIdx % colors.length];

      // Ø§Ù„Ù…Ø§Ø±ÙƒØ±Ø§Øª
      latlngs.forEach((ll, idx) => {
        const m = L.circleMarker(ll, { radius: 6, weight: 2, fillOpacity: 0.85, color: color });
        m.bindTooltip(
          `P${idx+1}<br/>N=${fmt(polyPts[idx].N,3)}<br/>E=${fmt(polyPts[idx].E,3)}`,
          { sticky: true }
        );
        m.addTo(pointsLayer);
      });

      // Ø§Ù„Ø®Ø· Ø§Ù„Ù…ØºÙ„Ù‚
      const closed = latlngs.slice();
      closed.push(latlngs[0]);
      L.polyline(closed, { weight: 3, opacity: 0.95, color: color }).addTo(pointsLayer);

      // Ø§Ù„Ù…Ø¶Ù„Ø¹ (Ù…Ø³Ø§Ø­Ø©)
      if(polyPts.length >= 3){
        L.polygon(latlngs, { weight: 2, fillOpacity: 0.20, color: color }).addTo(pointsLayer);
      }

      // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
      const stats = computeAreaPerimeter(polyPts);
      totalArea += stats.area;
      totalPerimeter += stats.perimeter;

      // Ø­Ø³Ø§Ø¨ Ù…Ø±ÙƒØ² Ø§Ù„Ù…Ø¶Ù„Ø¹ Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©
      const centroid = computePolygonCentroid(polyPts);

      // Ø¥Ù†Ø´Ø§Ø¡ Ø¨Ø·Ø§Ù‚Ø© HTML
      const cardHTML = `
        <div style="
          background: ${color}dd;
          border: 2px solid ${color};
          border-radius: 8px;
          padding: 10px;
          min-width: 150px;
          font-size: 12px;
          color: white;
          font-weight: bold;
          box-shadow: 0 2px 8px rgba(0,0,0,0.2);
          text-align: center;
          font-family: monospace;
        ">
          <div style="font-size: 13px; margin-bottom: 6px; text-decoration: underline;">Polygon ${polyIdx + 1}</div>
          <div style="font-size: 11px; margin: 3px 0;">Points: ${polyPts.length}</div>
          <div style="font-size: 11px; margin: 3px 0;">Area: ${fmt(stats.area, 2)} mÂ²</div>
          <div style="font-size: 11px; margin: 3px 0;">Perimeter: ${fmt(stats.perimeter, 2)} m</div>
        </div>
      `;
      
      // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø±ÙŠØ·Ø© ÙƒÙ€ popup Ø«Ø§Ø¨Øª Ø¹Ù†Ø¯ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù…Ø±ÙƒØ²
      L.popup({ closeButton: false, autoClose: false, className: 'polygon-card-popup' })
        .setLatLng([centroid.N, centroid.E])
        .setContent(cardHTML)
        .addTo(map);

      resultHTML += `<div style="margin-bottom: 12px; padding: 12px; background: ${color}22; border-left: 3px solid ${color}; border-radius: 8px;">
        <div style="font-weight: 800; margin-bottom: 6px; color: ${color};">Polygon ${polyIdx + 1}</div>
        <div style="font-size: 12px;">Points: ${polyPts.length}</div>
        <div style="font-size: 12px;">Area: ${fmt(stats.area, 3)} mÂ²</div>
        <div style="font-size: 12px;">Perimeter: ${fmt(stats.perimeter, 3)} m</div>
      </div>`;

      // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø¯ÙˆØ¯
      if(!allBounds) allBounds = L.latLngBounds(latlngs);
      else allBounds.extend(latlngs);
    });

    pointsLayer.addTo(map);

    // Ø¹Ø±Ø¶ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
    if(allBounds){
      map.fitBounds(allBounds.pad(0.2));
      setGridToBounds(allBounds.pad(0.2));
    }

    // Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ ÙˆØ§Ù„ØªÙØ§ØµÙŠÙ„
    document.getElementById('res-count').innerText = String(ptsInput.length);
    document.getElementById('res-area').innerText = fmt(totalArea, 3);
    document.getElementById('res-perimeter').innerText = fmt(totalPerimeter, 3);

    // Ø¥Ø¶Ø§ÙØ© ØªÙØ§ØµÙŠÙ„ ÙƒÙ„ Ù‚Ø·Ø¹Ø©
    const resultsContainer = document.getElementById('areaResults');
    const detailsDiv = document.createElement('div');
    detailsDiv.id = 'polygon-details';
    detailsDiv.innerHTML = resultHTML;
    resultsContainer.appendChild(detailsDiv);

    elResults.style.display = 'grid';

    if(polygons.length > 1){
      showMsg(`Detected ${polygons.length} polygons. Area and perimeter calculated for each.`, '');
    } else if(ptsInput.length < 3){
      showMsg('Drawing complete. Area calculation requires at least 3 points.', 'warn');
    } else {
      showMsg('Drawing and calculation completed successfully.', '');
    }
  }

  // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©: ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù†Ù‚Ø§Ø· Ø¥Ù„Ù‰ Ù…Ø¶Ù„Ø¹Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø©
  function splitPolygonsAtClosingPoint(pts){
    const method = document.getElementById('splitMethod')?.value || 'auto';
    
    if(method === 'duplicates'){
      return splitByDuplicates(pts);
    } else if(method === 'gaps'){
      return splitByGaps(pts);
    } else if(method === 'id'){
      return splitByIdReset(pts);
    } else {
      // ØªØ¬Ø±Ø¨Ø© Ø§Ù„ÙØµÙ„ Ø­Ø³Ø¨ ID Ø£ÙˆÙ„Ø§Ù‹ØŒ ÙˆØ¥Ø°Ø§ Ù„Ù… ÙŠØ¹Ø·Ù Ù†ØªØ§Ø¦Ø¬ØŒ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ©
      const idResult = splitByIdReset(pts);
      if(idResult.length > 1){
        return idResult;
      }
      return splitByAuto(pts);
    }
  }

  function splitByDuplicates(pts){
    const polygons = [];
    let currentPolygon = [];

    for(let i = 0; i < pts.length; i++){
      const currentPt = pts[i];
      
      if(currentPolygon.length === 0){
        currentPolygon.push(currentPt);
      } else {
        const firstPt = currentPolygon[0];
        
        // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù†Ù‚Ø·Ø© Ù…ØªØ·Ø§Ø¨Ù‚Ø© Ù…Ø¹ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
        if(pointsEqual(currentPt, firstPt, 0.01) && currentPolygon.length > 2){
          // Ø­ÙØ¸ Ø§Ù„Ù…Ø¶Ù„Ø¹ Ø¨Ø¯ÙˆÙ† Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø£Ø®ÙŠØ±Ø© (Ø§Ù„Ù…ÙƒØ±Ø±Ø©)
          polygons.push(currentPolygon);
          currentPolygon = [currentPt];
        } else {
          currentPolygon.push(currentPt);
        }
      }
    }

    if(currentPolygon.length >= 2){
      polygons.push(currentPolygon);
    }

    return polygons.length > 0 ? polygons : [pts];
  }

  function splitByGaps(pts){
    const polygons = [];
    let currentPolygon = [];
    const gapThreshold = 1000; // Ù…ØªØ±

    for(let i = 0; i < pts.length; i++){
      const currentPt = pts[i];
      
      if(currentPolygon.length === 0){
        currentPolygon.push(currentPt);
      } else {
        const prevPt = currentPolygon[currentPolygon.length - 1];
        const distN = Math.abs(currentPt.N - prevPt.N);
        const distE = Math.abs(currentPt.E - prevPt.E);
        const distance = Math.sqrt(distN * distN + distE * distE);
        
        // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„ÙØ¬ÙˆØ© ÙƒØ¨ÙŠØ±Ø© Ø¬Ø¯Ø§Ù‹
        if(distance > gapThreshold && currentPolygon.length >= 2){
          polygons.push(currentPolygon);
          currentPolygon = [currentPt];
        } else {
          currentPolygon.push(currentPt);
        }
      }
    }

    if(currentPolygon.length >= 2){
      polygons.push(currentPolygon);
    }

    return polygons.length > 0 ? polygons : [pts];
  }

  function splitByAuto(pts){
    const polygons = [];
    let currentPolygon = [];
    const gapThreshold = 1000; // Ù…ØªØ±

    for(let i = 0; i < pts.length; i++){
      const currentPt = pts[i];
      
      if(currentPolygon.length === 0){
        currentPolygon.push(currentPt);
      } else {
        const firstPt = currentPolygon[0];
        const prevPt = currentPolygon[currentPolygon.length - 1];
        
        // Ø§Ù„Ø­Ø§Ù„Ø© 1: Ù†Ù‚Ø·Ø© Ù…ØªØ·Ø§Ø¨Ù‚Ø© Ù…Ø¹ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
        const isDuplicate = pointsEqual(currentPt, firstPt, 0.01) && currentPolygon.length > 2;
        
        // Ø§Ù„Ø­Ø§Ù„Ø© 2: ÙØ¬ÙˆØ© ÙƒØ¨ÙŠØ±Ø©
        const distN = Math.abs(currentPt.N - prevPt.N);
        const distE = Math.abs(currentPt.E - prevPt.E);
        const distance = Math.sqrt(distN * distN + distE * distE);
        const hasGap = distance > gapThreshold && currentPolygon.length >= 2;
        
        if(isDuplicate || hasGap){
          polygons.push(currentPolygon);
          currentPolygon = [currentPt];
        } else {
          currentPolygon.push(currentPt);
        }
      }
    }

    if(currentPolygon.length >= 2){
      polygons.push(currentPolygon);
    }

    return polygons.length > 0 ? polygons : [pts];
  }

  function splitByIdReset(pts){
    // Ø§Ù„ÙØµÙ„ Ø­Ø³Ø¨ Ø¹Ù…ÙˆØ¯ ID: Ø¹Ù†Ø¯Ù…Ø§ ÙŠÙ†Ø®ÙØ¶ ID Ù…Ù† Ù‚ÙŠÙ…Ø© Ø£Ø¹Ù„Ù‰ Ù„Ù„Ù‚ÙŠÙ…Ø© 1ØŒ ÙŠÙƒÙˆÙ† Ù‡Ù†Ø§Ùƒ Ù…Ø¶Ù„Ø¹ Ø¬Ø¯ÙŠØ¯
    const polygons = [];
    let currentPolygon = [];

    for(let i = 0; i < pts.length; i++){
      const currentPt = pts[i];
      
      if(currentPolygon.length === 0){
        currentPolygon.push(currentPt);
      } else {
        const prevPt = currentPolygon[currentPolygon.length - 1];
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù†Ø®ÙØ§Ø¶ ID (Ø¥Ø´Ø§Ø±Ø© Ù„Ø¨Ø¯Ø§ÙŠØ© Ù…Ø¶Ù„Ø¹ Ø¬Ø¯ÙŠØ¯)
        const prevId = prevPt.id !== undefined ? prevPt.id : 1;
        const currId = currentPt.id !== undefined ? currentPt.id : 1;
        
        // Ø¥Ø°Ø§ ÙƒØ§Ù† ID Ø£Ù‚Ù„ Ù…Ù† Ø§Ù„Ø³Ø§Ø¨Ù‚ Ø¨ÙƒØ«ÙŠØ± Ø£Ùˆ Ø§Ù†Ø®ÙØ¶ Ù„Ù„Ù€ 1 Ø£Ùˆ 2ØŒ ÙÙ‡Ùˆ Ù…Ø¶Ù„Ø¹ Ø¬Ø¯ÙŠØ¯
        if(currId < prevId * 0.5 || (currId <= 2 && prevId > 5)){
          polygons.push(currentPolygon);
          currentPolygon = [currentPt];
        } else {
          currentPolygon.push(currentPt);
        }
      }
    }

    if(currentPolygon.length >= 2){
      polygons.push(currentPolygon);
    }

    return polygons.length > 0 ? polygons : [pts];
  }

  function importFromFile(file){
    const reader = new FileReader();
    reader.onload = () => {
      const content = String(reader.result || '');
      const { pts, badLines } = parsePoints(content);

      if(!pts.length){
        showMsg('No valid points found in file.', 'err');
        return;
      }
      if(badLines.length){
        showMsg(`Imported with ignored unreadable lines: ${badLines.join(', ')}.`, 'warn');
      } else {
        showMsg('Points imported successfully.', '');
      }

      elInput.value = pts.map(p => `${p.N}, ${p.E}`).join('\n') + '\n';
    };
    reader.onerror = () => showMsg('Failed to read file.', 'err');
    reader.readAsText(file);
  }

  // --- Events ---
  btnDraw.addEventListener('click', () => {
    const { pts, badLines } = parsePoints(elInput.value);
    if(badLines.length){
      showMsg(`Unreadable lines: ${badLines.join(', ')}. Each line must contain N and E.`, 'err');
      return;
    }
    if(!pts.length){
      showMsg('Enter points first.', 'warn');
      return;
    }
    render(pts);
  });

  btnImport.addEventListener('click', () => {
    fileInput.value = '';
    fileInput.click();
  });

  fileInput.addEventListener('change', (e) => {
    const f = e.target.files && e.target.files[0];
    if(f) importFromFile(f);
  });

  btnClear.addEventListener('click', () => {
    elInput.value = '';
    elResults.style.display = 'none';
    clearDraw();
    hideMsg();
    showMsg('Input and drawing cleared.', '');
  });

  showMsg('Ready. Enter your points then click "Draw & Calculate".', '');
})();
</script>
</body>
</html>
